Reflect about your solution!

Summary:
Client verbindet sich mit dem Server(CloudController) mittels einer TCP Verbindung. Der Server wartet schon auf eine TCP Verbindung, nimmt diese an und startet einen neuen Thread(CloudControllerWorker), damit sich der neue Thread um den Client kuemment kann und damit der Server weiter lauschen kann auf eine neue Verbindung. Dieser neue Thread wird in CloudController in einem executor abgelegt, damit er nicht verloren geht. Der exekutor bringt einige Vorteile. Zum Beispiel kann man definieren wie viele Threads gleichzeitig arbeiten sollen. Ich habe die Zahl bei 10 angesetzt. Die anderen Threads warten daweil ab, bis ein laufender Thread beendet wird. Und man kann auch noch beim beenden des executors alles Threads darin interrupten.

Der CloudController lauscht auf TCP Verbindungen und ebenfalls auf UDP Verbindungen. Nodes schicken Ihre !alive Nachrichten per UDP und der Server kommuniziert mit ihnen über TCP. Bei UDP ist (fast) kein Problem wenn ein Packet verloren geht. Bei TCP ist es schon ein Problem. Deshalb diese Wahl. Bei Nodes passiert dasselbe was bei Server. Eine Node wartet auf eine TCP Verbindung und wenn eine aufgebaut wird, wird ein neuer Thread(NodeWorker) gestartet und in exekutor abgelegt. Dieser definiert wieder wie viele Nodes gleichzeitig arbeiten können. Nach dem berechnen schliesst sich der Thread wieder. Das ist bei Client-Server TCP Verbindung nicht so. So lange nicht !exit aufgerufen wird(egal von welcher Seite), bleibt die Verbindung bestehen. Um alle Threads des Programms zu beenden, reicht es bei jedem(Client, Server, Node) das !exit auszuführen.